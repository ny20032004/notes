微处理器
=======

### 运算器
组成：

  * ALU（Arithmetic Logical Unit，算术逻辑单元）
  * 通用（或专用）寄存器
  * 内部总线

核心功能：

  * 实现数据的算术运算（加、减、乘、除）
  * 实现数据的逻辑运算（与、或、非、异）

#### 三种结构运算器：
 * 单总线结构运算器：只有一条内部总线，负责输出参与运算的两个数据，以及运算结果的输出。由于交由一条总线传输，效率低。
 * 双总线结构运算器：由两条内部总线传输参与运算的两个数据，而运算结果由其中一条内部总线负责输出，效率比单总线运算器高。
 * 三总线结构运算器：由两条内部总线传输参与运算的两个数据，由另一条内部总线输出运算结果，效率最高。这种设计在传送运算结果的同时就可以通过另外两条总线传送参加操作数运算的操作数，只要 ALU 足够快，运算过程可以一步完成。

### 控制器
 控制器的作用是控制程序的之城，它是整个系统的指挥中心。

#### 控制器需剧本以下基本功能：

 1. 指令控制
  * 控制器要能根据指令所在的地址按顺序或在遇到转移指令时按照转移地址取出指令，分析指令（指令移码），传送必要操作数，并在只能执行结束后存放运算结果。保证计算机中的指令流正常工作。
 2. 时序控制
  * 一条指令执行时间称为指令周期，不同指令的指令周期中所包含的机器周期数是不同的，而机器周期中包含多少个时钟周期也不一定相同。这些时序信号用于计算机的工作基准，他们由控制器产生，使系统按照一定时序关系进行工作。
 3. 操作控制
  * 根据指令流程，确定在指令周期的各个节拍（时钟周期）中要产生微操作控制信号，一有效地完成各条指令的操作过程。
  
#### 控制器内部主要组成

 1. 程序计数器PC（Programming Counter）。程序计数器用来存放下一条要执行指令在存储器中的地址。
 2. 指令寄存器IR（Instruction Register）。指令寄存器用于存放从存储器中取出待执行的指令。
 3. 指令译码器ID（Instruction Decoder）。指令寄存器中待执行的指令须经过“翻译”才能明白要进行怎样的操作，即指令译码。
 4. 时序控制部件。时序控制部件产生计算机工作中所需要的各种时序信号。
 5. 微操作控制部件。控制器的主体。用于产生与各条指令想对应的微操作控制。它根据当前正在执行的指令，在指令的各机器周期的各个节拍内产生相应的微操作控制新红啊，从而控制整个系统各部件的工作。

### 8088/8086 CPU 特点

#### 8088/8086 的指令执行流

CPU 总是有规律地重复执行一下步骤：

 1. 从存储器中取出下一条指令
 2. 指令移码（或分析指令）
 3. 如果指令需要，从存储器中读取操作数
 4. 执行治疗你给（包括算术逻辑运算，I/O操作，数据传送，控制转移等）
 5. 如果需要，将结果写入存储器中。

8088/8086 将上述步骤分配给 CPU 内两个独立的部件： __执行单元（Execution Unit，EU）__ 和 __总线接口单元（Bus Interface Unit，BIU）__ 。

* EU负责分析指令（指令移码）和执行指令
* BIU 负责取指令、取操作数和写结果。

这两个单元都能够独立地完成各自相应的工作。所以，当这两个单元并行工作时，在大多数情况下，取指令操作与执行指令操作都可以重叠地进行。因为 BIU 已经从存储器中将 EU 要执行的指令“预取”了出来，所以大多数情况下“省掉”了取指令的时间，从而加快了程序的运行速度。

#### 内存的分段管理技术
 8088/8086 CPU 的内部结构都是16位的，即内部的寄存器只能存放16位的二进制码，内部的总线同时也只能传送16位二进制码。如果用二进制码表示地址，则最多只能产生 2^16 = 64K 个地址，也就是最多能够管理 64 个内存单元。

 内存容量的大小对计算机的性能有直接影响，为了提高系统的执行速度，人们希望尽可能地提高系统管理（寻址）内存的能力。
 
 8088/8086 CPU 采用了分段管理的方法，将内存地址空间非为多个逻辑段，每个逻辑段最大为 64K 个单元，段内每个单元的地址码（称为偏移地址或相对地址）长度为 16位，满足其 16位 内部结构的要求；再为每个段设置段地址（也称段基地址），以区分不同的逻辑段。

 __Notes: __

  * 内存结构：
    * 指令和数据都存放在存储器中，也就是平时所说的内存。
    * 内存被划分为若干个存储单元（内存单元），存储单元从 0 开始顺序编号。
    * 内存由地址译码器和内存单元构成。
    * CPU通过地址总线（地址码）来指定要访问的存储单元，地址总线上能传输多少不同的信息，CPU 就可以对多少个存储单元进行寻址。因此 CPU 有 N 条地址总线，则该 CPU 最多可以有 2^N 个不同的寻址。
    * 8088 CPU 有 20 条地址总线，寻址大小 1M。
  * 内存存储内容：
    * 机器字长是 16 bit，数据是以字节（8 bit）来为单位表示。
    * 一个字存入存储器，占用相继的两个存储单元，高位字节存储高位地址，低位字节存入低位地址。
    * 字节用 AL, BL..表示， 字用 AX, BX 表示。
  * 出现存储器分段管理的原因：8086 有 20 条地址总线，而 CPU 内部为 16 bit 结构，表现出的寻址能力只有 2^16 = 64KB. 而不是 _地址总线_ 能表示的 1M。
  * 何为物理地址？CPU 访问内存单元的时候需要给出单元的地址，这些单元构成一个一维线性存储空间，而内存单元在这个存储空间中的唯一地址，就是存储单元的物理地址。
  * 分段：程序装入内存时，按段进行管理，分为：代码段、数据段、堆栈段。
  * 8086 段：
    * 段长度 ≤ 64KB
    * 段的起始地址必须是 16 位的整数倍。
    * _段起始地址_ ：程序某段在内存的起点物理地址。
    * _段地址_ ：某段起始地址的高 16 位，放在段寄存器中。
    * _段偏移地址_ ： 又称 _有效地址_ ， _逻辑地址_ 内存单元距离所属段起点的偏移量。
    * 段起始地址 = 段地址 * 10H = 段地址左移 4 位。
    * 单元物理地址 = 段起始地址 + 段偏移地址 = 段地址 * 10H + 段偏移地址   
    * 内存单元地址用 __段地址：偏移地址__ 的方式来描述
    * 代码段 CS:IP ，数据段 DS:SI(DI,BX) ， 堆栈段 SS:SP(BP)
  * 堆栈操作
    * PUSH 推入堆栈， POP 弹出堆栈
    * 堆栈操作是按 字 操作的。
    * PUSH XX ，将 XX 的内容推入堆栈，SP 减 2。
    * POP XX，将栈顶内容弹到 XX， SP 加 2。
    * 堆栈操作永远在栈顶进行，SP 永远指向栈顶。
    * SP 的初始值决定堆栈的大小
    * 任何时刻 SP 数值反映堆栈剩余空间大小，这也是为什么 PUSH 时 SP 减少， POP 时 SP 增加。

  