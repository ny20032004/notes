编译原理
-----------------------

1. 引论
    1. 语言处理器
    1. 一个编译器的结构
        1. 词法分析
        1. 语法分析
        1. 语义分析
        1. 中间代码生成
        1. 代码优化
        1. 代码生成
        1. 符号表管理
        1. 将多个步骤组合成趟
        1. 编译器构造工具
    1. 程序设计语言的发展历程
        1. 走向高级程序设计语言
        1. 对编译器的影响
    1. 构建一个编译器的相关科学
        1. 编译器设计和实现中的建模
        1. 代码优化的科学
    1. 编译技术的应用
        1. 高级程序设计语言的实现
        1. 针对计算机体系结构的优化
        1. 新计算机体系结构的设计
        1. 程序翻译
        1. 软件生产率工具
    1. 程序设计语言基础
        1. 静态和动态的区别
        1. 环境与状态
        1. 静态作用域和块结构
        1. 显式访问控制
        1. 动态作用域
        1. 参数传递机制
        1. 别名

1. 一个简单的语法制导翻译器
    1. 语法定义
        1. 文法定义
        1. 推导
        1. 语法分析树
        1. 二义性
        1. 运算符的结合性
        1. 运算符的优先级
    1. 语法制导翻译
        1. 后缀表示
        1. 综合属性
        1. 简单语法制导定义
        1. 树的遍历
        1. 翻译方案
    1.语法分析
        1. 自顶向下分析方法
        1. 预测分析法
        1. 何时使用?-产生式
        1. 设计一个预测语法分析器
        1. 左递归
    1. 简单表达式的翻译器
        1. 抽象语法和具体语法
        1. 调整翻译方案
        1. 非终结符号的过程
        1. 翻译器的简化
        1. 完整的程序
    1. 词法分析
        1. 剔除空白和注释
        1. 预读
        1. 常量
        1. 识别关键字和标识符
        1. 词法分析器
    1. 符号表
        1. 为每个作用域设置一个符号表
        1. 符号表的使用
    1. 中间代码生成
        1. 两种中间表示形式
        1. 语法树的构造
        1. 三地址码

1. 词法分析
    1. 词法分析器的作用
        1. 词法分析及解析
        1. 词法单元、模式、词素
        1. 词法单元的属性
        1. 词法错误
    1. 输入缓冲
        1. 缓冲区对
        1. 哨兵标记
    1. 词法单元的规约
        1. 串和语言
        1. 语言上的运算
        1. 正则表达式
        1. 正则定义
        1. 正则表达式的扩展
    1. 词法单元的识别
        1. 状态转换图
        1. 保留字和标识符的识别
        1. 完成我们的连续性例子
        1. 基于状态转换图的词法分析器的体系结构
    1. 词法分析器生成工具Lex
        1. Lex的使用
        1. Lex程序的结构
        1. Lex中的冲突解决
        1. 向前看运算符
    1. 有穷自动机
        1. 不确定的有穷自动机
        1. 转换表
        1. NFA接受输入字符串
        1. 确定的有穷自动机
    1. 从正则表达式到自动机
        1. 从NFA到DFA的转换
        1. NFA的模拟
        1. NFA模拟效率
        1. 从正则表达式构造NFA
        1. 字符串处理算法的效率
   1. 词法分析器生成工具的设计
        1. 被生成的词法分析器的结构
        1. 基于NFA的模式匹配
        1. 词法分析器使用的DFA
        1. 实现向前看运算符
    1. 基于DFA的模式匹配器的优化
        1. NFA的重要状态
        1. 根据抽象语法树计算得到的函数
        1. 计算nullable、firstpos及lastpos
        1. 计算followpos
        1. 根据正则表达式构建DFA
        1. 最小化一个DFA的状态数
        1. 词法分析器的状态最小化
        1. 在DFA模拟中用时间换取空间

1. 语法分析
    1. 引论
        1. 语法分析器的角色
        1. 代表性的文法
        1. 语法错误的处理
        1. 错误恢复策略
    1. 上下文无关文法
        1. 上下文无关文法的正式定义
        1. 符号表示的惯例
        1. 推导
        1. 语法分析树和推导
        1. 二义性
        1.验证文法生成的语言
        1.上下文无关文法和正则表达式
    1. 设计文法
        1. 词法分析和语法分析
        1. 消除二义性
        1. 左递归的消除
        1. 提取左公因子
        1. 非上下文无关的语言构造
    1. 自顶向下的语法分析
        1. 递归下降的语法分析
        1. FIRST和FOLLOW
        1. LL(1)文法
        1. 非递归的预测分析
        1. 预测分析中的错误恢复
    1. 自底向上的语法分析
        1. 归约
        1. 句柄剪枝
        1. 移入-归约语法分析技术
        1. 移入-归约语法分析中的冲突
    1. LR语法分析技术介绍：简单LR技术
        1. 为什么使用LR语法分析器？
        1. 项和LR(0)自动机
        1. LR-语法分析算法
        1. 构造SLR-分析表
        1. 可行前缀
    1. 更强大的LR语法分析器
        1. 规范LR(1)项
        1. 构造LR(1)项集
        1. 规范LR(1)分析表
        1. 构造LALR语法分析表
        1. LALR语法分析表的高效构造方法
        1. LR语法分析表的压缩
    1. 使用二义性文法
        1. 用优先级和结合性解决冲突
        1. "悬空-else"二义性
        1. LR语法分析中的错误恢复
    1. 语法分析器的生成工具
        1. 语法分析器的生成工具Yacc
        1. 使用Yacc处理二义性文法
        1. 用Lex创建Yacc的词法分析器
        1.：Yacc中的错误恢复

1. 语法制导的翻译
    1. 语法制导定义
        1. 继承属性和综合属性
        1. 在一棵语法分析树的结点上对一个SDD求值
    1. SDD的求值顺序
        1. 依赖图
        1. 属性求值的顺序
        1. S-属性定义
        1. L-属性定义
        1. 具有受控副作用的语义规则
    1. 语法制导翻译的应用
        1. 抽象语法树的构造
        1. 类型的结构
    1. 语法制导的翻译方案
        1. 后缀翻译方案
        1. 后缀SDT的语法分析栈实现
        1. 产生式内部带有语义动作的SDT
        1. 从SDT中消除左递归
        1. L-属性定义的SDT
    1. 实现L-属性的SDD
        1. 在递归下降语法分析过程中进行翻译
        1. 边扫描边生成代码
        1. L-属性的SDD和LL语法分析
        1. L-属性的SDD的自底向上语法分析

1. 中间代码生成
    1. 语法树的变体
        1. 表达式的有向无环图
        1. 构造DAG的值编码方法
    1. 三地址代码
        1. 地址和指令
        1. 四元式表示
        1. 三元式表示
        1. 静态单赋值形式
    1. 类型和声明
        1. 类型表达式
        1. 类型等价
        1. 声明
        1. 局部变量名的存储布局
        1. 声明的序列
        1. 记录和类中的域
    1. 表达式的翻译
        1. 表达式中的运算
        1. 增量翻译
        1. 数组元素的寻址
        1. 数组引用的翻译
    1. 类型检查
        1. 类型检查规则
        1. 类型转换
        1. 函数和运算符的重载
        1. 类型推导和多态函数
        1. 一个合一算法
    1. 控制流
        1. 布尔表达式
        1. 短路代码
        1. 控制流语句
        1. 布尔表达式的控制流翻译
        1. 避免冗余的goto指令
        1. 布尔值和跳转代码
    1. 回填
        1. 使用回填技术的一趟式目标代码生成
        1. 布尔表达式的回填
        1. 控制转移语句
        1. Break-, Continue-和Goto-语句
    1. Switch-语句
        1. Switch语句的翻译
        1. Switch语句的语法制导翻译
    1. 过程的中间代码

1. 运行时刻环境
    1. 存储组织
        1. 静态和动态存储分配
    1. 空间的栈式分配
        1. 活动树
        1. 活动记录
        1. 调用代码序列
        1. 栈中的变长数据
    1. 栈中非局部数据访问
        1. 没有嵌套过程时的数据访问
        1. 和嵌套过程相关的问题
        1. 一个允许嵌套过程声明的语言
        1. 嵌套深度
        1. 访问链
        1. 处理访问链
        1. 过程型参数的访问链
        1. 显示表
    1. 堆管理
        1. 存储管理子系统
        1. 一台计算机的存储层次结构
        1. 程序中的局部性
        1. 碎片整理
        1. 人工回收请求
    1. 垃圾回收介绍
        1. 垃圾回收的设计目标
        1. 可达性
        1. 引用计数垃圾回收器
    1. 基于跟踪的回收的介绍
        1. 基本的标记并清扫回收器
        1. 基本抽象
        1. 标记并清扫算法的优化
        1. 标记并压缩的垃圾回收器
        1. 拷贝回收器
        1.开销的比较
    1. 短停顿垃圾回收
        1. 增量式垃圾回收
        1. 增量式可达分析
        1. 部分回收基础
        1. 世代垃圾回收
        1. 列车算法
    1. 垃圾回收中的高级论题
        1. 并行和并发垃圾回收
        1. 部分的对象重新定位
        1.类型不安全的语言的保守垃圾回收
        1. 弱引用

1. 代码生成
    1. 代码生成器设计中的问题
        1. 代码生成器的输入
        1. 目标程序
        1. 指令选择
        1. 寄存器分配
        1. 求值顺序
    1. 目标语言
        1. 一个简单的目标机模型
        1. 程序和指令的代价
    1. 目标代码中的地址
        1. 静态分配
        1. 栈分配
        1. 名字的运行时刻地址
    1. 基本块和流图
        1. 基本块
        1. 后续使用信息
        1. 流图
        1. 流图的表示方式
        1. 循环
    1. 基本块的优化
        1. 基本块的DAG图表示
        1. 寻找局部公共子表达式
        1. 死代码消除
        1. 代数恒等式的使用
        1. 数组指引的表示
        1. 指针赋值和过程调用
        1. 从DAG图到基本块的重组
    1. 一个简单的代码生成器
        1. 寄存器和地址描述符
        1. 代码生成算法
        1. 函数getReg的设计
    1. 窥孔优化
        1. 消除冗余的加载和保存指令
        1. 消除不可达代码
        1. 控制流优化
        1. 代数简化和强度消减
        1. 使用机器特有的指令
    1. 寄存器分配和指派
        1. 全局寄存器分配
        1. 使用计数
        1. 外层循环的寄存器指派
        1. 通过图着色方法进行寄存器分配
    1. 通过树重写进行指令选择
        1. 树翻译方案
        1. 通过覆盖一个输入树来生成代码
        1. 通过扫描进行模式匹配
        1. 用于语义检查的子过程
        1. 通用的树匹配方法
    1. 表达式的优化代码生成
        1. Ershov数
        1. 从带标号的表达式树生成代码
        1. 寄存器数量不足时的表达式求值
    1. 使用动态规划的代码生成
        1. 连续求值
        1. 动态规划的算法
        1.     1.1节的练习

1. 机器无关优化
    1. 优化的主要来源
        1. 冗余的原因
        1. 一个贯穿本章的例子
        1. 保持语义不变的转换
        1. 全局公共子表达式
        1. 复制传播
        1. 死代码消除
        1. 代码移动
        1. 归纳变量和强度消减
    1. 数据流分析简介
        1. 数据流抽象
        1. 数据流分析方案
        1. 基本块上的数据流方案
        1. 到达定值
        1. 活跃变量分析
        1. 可用表达式
        1. 小结
    1. 数据流分析基础
        1. 半格
        1. 传递函数
        1. 通用框架的迭代算法
        1. 数据流解的含义
    1. 常量传播
        1. 常量传播框架的数据流值集
        1. 常量传播框架的交函数
        1. 常量传播框架的传递函数
        1. 常量传递框架的单调性
        1. 常量传播框架的不可分配性
        1. 对算法结果的解释
    1. 部分冗余消除
        1. 冗余的来源
        1. 可能消除所有冗余吗？
        1. 懒惰代码移动问题
        1. 表达式的预期执行
        1. 懒惰代码移动算法
    1. 流图中的循环
        1.支配结点
        1. 深度优先排序
        1. 深度优先生成树中的边
        1. 回边和可归约性
        1. 流图的深度
        1. 自然循环
        1. 迭代数据流算法的收敛速度
    1. 基于区域的分析
        1. 区域
        1. 可归约流图的区域层次结构
        1. 基于区域的分析技术的概览
        1. 有关传递函数的必要假设
        1. 一个基于区域的分析算法
        1. 处理不可归约流图
    1. 符号分析
        1. 参考变量的仿射表达式
        1. 数据流问题的公式化
        1. 基于区域的符号化分析

1. 指令级并行
    1. 处理器体系结构
        1.  指令流水线和分支延时
        1. 流水线执行
        1. 多指令发送
    1. 代码调度约束
        1. 数据依赖
        1. 寻找内存访问之间的依赖关系
        1. 寄存器使用和并发性之间的折衷处理
        1. 寄存器分配阶段和代码调度阶段之间的顺序
        1. 控制依赖
        1. 对投机执行的支持措施
        1. 一个基本的机器模型
    1. 基本块调度
        1. 数据依赖图
        1. 基本块的列表调度方法
        1. 带有优先级的拓扑排序
    1. 全局代码调度
        1. 基本的代码移动
        1. 向上的代码移动
        1. 向下的代码移动
        1. 更新数据依赖关系
        1. 全局调度算法
        1. 高级代码移动技术
        1. 和动态调度器的交互
    1. 软件流水线化
        1. 引言
        1. 循环的软件流水线化
        1. 寄存器分配和代码生成
        1. Do-Across循环
        1. 软件流水线化的目标和约束
        1. 一个软件流水线化算法
        1. 对无环数据依赖图进行调度
        1. 对有环的数据依赖图进行调度
        1. 对流水线化算法的改进
        1. 模组变量扩展
        1. 条件语句
        1. 软件流水线化的硬件支持

1. 并行性和局部性的优化
    1. 基本概念
        1. 多处理器
        1. 应用中的并行性
        1. 循环层次的并行性
        1. 数据局部性
        1. 仿射变换理论的介绍
    1. 矩阵乘法：一个深入的例子
        1. 矩阵相乘算法
        1. 优化
        1. 高速缓存干扰
    1. 迭代空间
        1. 从循环嵌套结构中构建迭代空间
        1. 循环嵌套结构的执行顺序
        1. 不等式组的矩阵表示方法
        1. 混合使用符号常量
        1. 控制执行的顺序
        1. 坐标轴的变换
    1. 仿射的数组下标
        1. 仿射访问
        1. 实践中的仿射访问和非仿射访问
    1. 数据复用
        1. 数据复用的类型
        1. 自复用
        1. 自空间复用
        1. 组复用
    1. 数组数据依赖分析
        1. 数组访问的数据依赖关系的定义
        1. 整数线性规划
        1. GCD测试
        1. 解决整数线性规划的启发式规则
        1. 解决一般性的整数线性规划问题
        1. 小结
    1. 寻找无同步的并行性
        1. 一个介绍性的例子
        1. 仿射空间分划
        1. 空间分划约束
        1. 求解空间分划约束
        1. 一个简单的代码生成算法
        1. 消除空迭代
        1. 从最内层循环中消除条件测试
        1. 源代码转换
    1. 并行循环之间的同步
        1. 固定多个同步运算
        1. 程序依赖图
        1. 层次结构化的时间
        1. 并行化算法
    1. 流水线化技术
        1. 什么是流水线化？
        1. 连续过松弛方法：一个例子
        1. 完全可交换循环
        1. 把完全可交换循环流水线化
        1. 一般性的理论
        1. 时间分划约束
        1. 用Farkas引理解时间分划约束
        1. 代码转换
        1. 具有最小同步量的并行性
    1. 局部性优化
        1. 计算结果数据的时间局部性
        1. 数组收缩
        1. 分划单元的交织
    1. 仿射转换的其它用途
        1. 分布式内存计算机
        1. 多指令发送处理器
        1. 向量和SIMD指令
        1. 数据预取

1. 程间分析
    1. 基本概念
        1. 调用图
        1. 上下文相关
        1. 调用串
        1. 基于克隆的上下文相关分析
        1. 基于摘要的上下文相关分析
    1. 为什么需要过程间分析？
        1. 虚例程调用
        1. 指针别名分析
        1. 并行化
        1. 软件错误和漏洞的检测
        1. SQL注入
        1. 缓冲区溢出
    1. 数据流的一种逻辑表示方式
        1. Datalog介绍
        1. Datalog规则
        1. 内涵断言和外延断言
        1. Datalog程序的执行
        1. Datalog程序的增量执行
        1. 有问题的Datalog规则
    1. 一个简单的指针分析算法
        1. 指针分析为什么困难
        1. 一个指针和引用的模型
        1. 控制流无关性
        1. 在Datalog中的表示方法
        1. 使用类型信息
    1. 上下文无关的过程间分析
        1. 一个例程调用的效果
        1. 用Datalog来发现调用图
        1. 动态加载和反射
    1. 上下文相关指针分析
        1. 上下文和调用串
        1. 在Datalog规则中加入上下文信息
        1. 关于相关性的更多讨论
    1. 使用BDD的Datalog的实现
        1. 二分决策图
        1. 对BDD的转换
        1. 用BDD表示关系表
        1. 用BDD操作实现关系操作
        1. 在指针指向分析中使用BDD
